{
  "name" : "NLP Data Structures",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "At the heart of any NLP library you find data structures that store source \nand meta information of textual documents. Many of them are organized hierarchically in\nthe following way:\n\n* Tokens, containing words and often character offsets\n* Sentences, containing a sequence of tokens\n* Documents, containing a sequence of sentences \n\nIn addition, each layer may contain further annotation that has been generated \nthrough the application of NLP techniques. For example, a sentence may also contain a representation of a syntactic tree, while a document may contain a representation of coreference chains. \n\n## Design Decisions\n\n* Mutable vs Immutable\n* Deep class hierarchies vs flat compositional structures\n* Character Offsets vs sequential representation\n\n## NLP Data Structures in Wolfe\nNLP data structures are *immutable*, *flat compositional* and *offset-based* representations.\n\n* Tokens in Wolfe are represented through the `Token` case class:",
      "extraFields" : { }
    }
  }, {
    "id" : 1,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "// A simple Token\nToken(\"scratched\") \n\n// A fully-specified Token\nToken(word = \"scratched\", \n      posTag = \"VBD\", \n      offsets = CharOffsets(0,9), \n      lemma = \"scratch\")",
      "extraFields" : {
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "* Token sequences can be wrapped in the `Sentence` case class to incorporate additional sentence-level reasoning:",
      "extraFields" : { }
    }
  }, {
    "id" : 3,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val s = \"The cat scratched the man\".split(\" \").foldLeft(Sentence.empty) { case(s,w) => s + Token(w) }\ns.words",
      "extraFields" : {
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 31,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Additional linguistic annotation is provided through optional annotation case classes.  Annotating a sentence with a `ConstituentTree` can be done using the `SyntaxAnnotation` class as follows:",
      "extraFields" : { }
    }
  }, {
    "id" : 32,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val tokens = IndexedSeq(Token(\"the\"), Token(\"cat\"), Token(\"scratches\"))\nval wsjStr = \"(S (NP (DET the) (NN cat)) (VP (VB scratches)))\"\nval tree = ml.wolfe.nlp.io.ConstituentTreeFactory.stringToTree(wsjStr).get\nval s = Sentence(tokens, syntax = SyntaxAnnotation(tree = tree, dependencies = null))\ns.syntax.tree.toTreebankString",
      "extraFields" : {
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 4,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "The `Document` class adds yet another level to the heirarchy, coupling a sequence of sentences to other document-level annotations, such as id, filename, or coreference:",
      "extraFields" : { }
    }
  }, {
    "id" : 5,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val d = Document()",
      "extraFields" : {
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 6,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Bidirectional Navigation\nThe immutable nature of Wolfe NLP data structures means that it is difficult to store\nback-links from tokens to sentences, or sentences to documents, due to the following\nchicken and egg problem: to create a new sentence\nI first need to create the tokens, but if they need back links to sentences, I first need \nto create the sentence. \n\nWolfe overcomes the above problem by creating a bidirectional object graph after the construction\nof the complete document. This graph can then be accessed for traversal in any direction. \nCrucially, using Scala's `implicit class` feature (link), graph navigation methods can be\naccesses directly through the token, sentence etc. classes, and to the user it appears *as if*\nthe data structures provide navigation directly. Example below...\n",
      "extraFields" : { }
    }
  }, {
    "id" : 7,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val s = \"The cat scratched the man\".split(\" \").foldLeft(Sentence.empty) { case(s,w) => s + Token(w) }\ns.words",
      "extraFields" : {
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 8,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Conclusion\nThe ",
      "extraFields" : { }
    }
  } ],
  "config" : { }
}
