{
  "name" : "Parsing",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nNote that this chapter is heavily influenced by the structure and content of [Mike Collins' PCFG lecture](http://www.cs.columbia.edu/~mcollins/courses/nlp2011/notes/pcfgs.pdf). <span class=\"summary\">Based on Mike Collins [Lecture](http://www.cs.columbia.edu/~mcollins/courses/nlp2011/notes/pcfgs.pdf).</span> \n\n<div class=\"newslide\"></div>\nIn many NLP applications it is useful to understand the syntactic structure of a sentence: where are the verbs, what are the subject and object of the verbs, which phrases form coherent sub-structures of the sentence? Understanding this enables the machine to more effectively translate from Japanese to English, or to understand the query [\"who is the president of the united state\"](https://www.google.co.uk/search?q=who+is+the+president+of+the+united+state&oq=who+is+the+president+of+the+united+state&aqs=chrome..69i57j0l5.252j0j4&sourceid=chrome&es_sm=119&ie=UTF-8) and execute it against a database. <span class=\"summary\">It is useful to understand the syntactic structure of a sentence: where are the _verbs_, what are the _subject_ and _object_ of the verbs, which _phrases_ form coherent _sub-structures_?</span>  \n\n<div class=\"newslide\"></div>\nIn linguistics these questions are asked in the field of **syntax**, from the Greek syntaxis (arrangement). There are three core concepts:\n\n* **Constituency**: groups of words act as single units.\n* **Grammatical Relations**: object, subject, direct object etc. \n* **Subcategorization**: restrictions on the type of phrases that go with certain words.\n\n<div class=\"newslide\"></div>\n### Context Free Grammars\nA common approach to capture constituency, grammatical relations and subcategorization is based on [Context Free Grammars](https://www.cs.rochester.edu/~nelson/courses/csc_173/grammars/cfg.html) (CFGs). On a high level, these grammars assume that legal sentences can be derived by repeatedly and _independently_ expanding abstract symbols (such as \"NounPhrase\" or \"Adjective\") into more concrete sequences of symbols (such as \"Adjective Noun\" or \"green\") until each symbol is a concrete word. <span class=\"summary\">Context Free Grammars define rules that expand ...</span> \n\n<div class=\"newslide\"></div>\nMore formally, a CFG is a 4-tuple \\\\(G=(N,\\Sigma,R,S)\\\\) where\n\n  * \\\\(N\\\\) is a set of _non-terminal symbols_.\n  * \\\\(\\Sigma\\\\) is a set of _terminal symbols_.\n  * \\\\(R\\\\) is a finite set of _rules_ \\\\(X \\rightarrow Y_1 Y_2\\ldots Y_n\\\\) where \\\\(X \\in N\\\\) and \\\\(Y_i \\in N \\cup \\Sigma\\\\). \n  * \\\\(S \\in N\\\\) is a _start symbol_. \n\n<div class=\"newslide\"></div>\nBefore we show examples, let us define a scala data structure for PCFGs.",
      "extraFields" : { }
    }
  }, {
    "id" : 1,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "sealed trait RHS\ncase class NonTerminal(name:Symbol) extends RHS \ncase class Terminal(name:String) extends RHS \ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\n1",
      "extraFields" : {
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nLet us now create an example CFG. Notice that we implemented a  implicit conversion methods which will allow us to construct terminals, non-terminals and rules more succinctly. We omit these methods here for brevity. <span class=\"summary\">Let us now create an example CFG</span> ",
      "extraFields" : { }
    }
  }, {
    "id" : 3,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "implicit def toNonTerm(name:Symbol) = NonTerminal(name)\nimplicit def toTerm(word:String) = Terminal(word)\nval anyToRhs:PartialFunction[Any,RHS] = {\n  case s:String => toTerm(s) \n  case s:Symbol => toNonTerm(s) \n}\nimplicit def toRule1(rule:(Symbol,List[Any])) = \n  Rule(rule._1,rule._2.collect(anyToRhs)) \n\nimplicit def toRule2(rule:(Symbol,Any)) = \n  Rule(rule._1,List(anyToRhs(rule._2))) \n    \ndef rhsToString(rhs:RHS) = rhs match {\n  case NonTerminal(n) => n.toString\n  case Terminal(w) => w\n}    \nimplicit def toHTML(cfg:CFG) = {\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\n    }  \n  }      \n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\" \"))))    \n}\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\" \"))))    \n}\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\n  CFG(nonTerminals,terminals,rules.toList,start)\n}",
      "extraFields" : {
        "hide" : "true",
        "hide_output" : "true",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\"]"
      }
    }
  }, {
    "id" : 4,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val cfg = cfgFromRules('S,\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \n  'NP_p -> List(\"MCRiedel\",\"raps\"),\n  'VP_p -> List(\"are\", 'ADJ),\n  'NP_s -> List(\"MCRiedel\"),\n  'VP_s -> List(\"raps\", \"in\", \"StatNLP\"),\n  'ADJ -> \"silly\")\ncfg ",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\"]"
      }
    }
  }, {
    "id" : 5,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### (Left-most) Derivation\nA left-most derivation given a CFG \\\\(G\\\\) is a sequence of strings \\\\(s_1 \\ldots s_n\\\\) such that \n\n* \\\\(s_1 = S\\\\), that is, the first string consists only of the start symbol.\n* \\\\(s_n \\in \\Sigma^*\\\\), that is, the last string consists of only terminals.\n* Each \\\\(s_i\\\\) for \\\\(i > 1\\\\) is generated by replacing the left-most non-terminal \\\\(\\alpha\\\\) with the right-hand side of any rule that has \\\\(\\alpha\\\\) as left-hand side. \n\n<div class=\"newslide\"></div>\nLet us write some code that puts this definition into action and generates random derivations based on a grammar. ",
      "extraFields" : { }
    }
  }, {
    "id" : 6,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import scala.collection.mutable.{ArrayBuffer,ListBuffer}\nval rand = new scala.util.Random(0) \n@scala.annotation.tailrec\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\n    case Some((n,index)) =>\n      val rules =  cfg.R.filter(_.lhs == n)\n      val sampled = rules(rand.nextInt(rules.length))\n      val next = sentence.patch(index,sampled.rhs,1) \n      generateDeriv(cfg, next, result.get :+ next)\n    case None => result \n  }",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP,'VP),   \\n  'VP -> List('VB), 'VP -> List('VB,'PP), 'VP -> List('VB,'ADJ),\\n  'PP -> List('IN, 'NP),\\n  'VB -> \\\"are\\\", 'VB -> \\\"raps\\\",\\n  'NP -> List('NX,'NX),'NP -> 'NX, 'NP -> List('ADJ,'NP),\\n  'NX -> \\\"StatNLP\\\", 'NX -> \\\"MCRiedel\\\", 'NX -> \\\"raps\\\",\\n  'IN -> \\\"during\\\",\\n  'ADJ -> \\\"silly\\\")\\ncfg \"]",
        "hide_output" : "true"
      }
    }
  }, {
    "id" : 7,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nLet us generate an example derivation.",
      "extraFields" : { }
    }
  }, {
    "id" : 8,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "generateDeriv(cfg,Seq(cfg.S))   ",
      "extraFields" : {
        "cache" : "false",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"MCRiedel\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"MCRiedel\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\"]"
      }
    }
  }, {
    "id" : 9,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Parse Trees\nDerivations can be compactly present as trees where each non-leaf node corresponds to an expanded left-hand-side and its children to the rules' right hand side.\n<span class=\"summary\">Derivations can be compactly present as trees where each non-leaf node corresponds to an expanded left-hand-side and its children to the rules' right hand side.</summary>\n\n<div class=\"newslide\"></div>\n<span class=\"summary\">A scala data structure to represent trees</summary>",
      "extraFields" : { }
    }
  }, {
    "id" : 10,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "sealed trait ParseTree { def node: RHS}\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\ncase class Leaf(node:Terminal) extends ParseTree",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP,'VP),   \\n  'VP -> List('VB), 'VP -> List('VB,'PP), 'VP -> List('VB,'ADJ),\\n  'PP -> List('IN, 'NP),\\n  'VB -> \\\"are\\\", 'VB -> \\\"raps\\\",\\n  'NP -> List('NX,'NX),'NP -> 'NX, 'NP -> List('ADJ,'NP),\\n  'NX -> \\\"StatNLP\\\", 'NX -> \\\"MCRiedel\\\", 'NX -> \\\"raps\\\",\\n  'IN -> \\\"during\\\",\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S))\"]",
        "hide_output" : "true"
      }
    }
  }, {
    "id" : 11,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import ml.wolfe.nlp.syntax._\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\n  case Leaf(Terminal(w)) => RenderTree(w,\"terminal\")\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \"nonterminal\",children map toRenderTree)\n}\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\n",
      "extraFields" : {
        "hide" : "true",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP,'VP),   \\n  'VP -> List('VB), 'VP -> List('VB,'PP), 'VP -> List('VB,'ADJ),\\n  'PP -> List('IN, 'NP),\\n  'VB -> \\\"are\\\", 'VB -> \\\"raps\\\",\\n  'NP -> List('NX,'NX),'NP -> 'NX, 'NP -> List('ADJ,'NP),\\n  'NX -> \\\"StatNLP\\\", 'NX -> \\\"MCRiedel\\\", 'NX -> \\\"raps\\\",\\n  'IN -> \\\"during\\\",\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S))\",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\"]"
      }
    }
  }, {
    "id" : 12,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "We can construct trees through parse the usual case class constructors, and render them graphically.",
      "extraFields" : { }
    }
  }, {
    "id" : 13,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "Node('S, List(Node('NP_p, List(Leaf(\"MCRiedel\"), Leaf(\"raps\"))),\n              Node('VP_p,List(Leaf(\"are\"), Leaf(\"silly\")))))",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"MCRiedel\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"MCRiedel\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S))   \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\"]"
      }
    }
  }, {
    "id" : 14,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nIn the same way we could generate derivations before, we can now generate parse trees from a CFG.",
      "extraFields" : { }
    }
  }, {
    "id" : 15,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\n  case t:Terminal => Leaf(t)\n  case n:NonTerminal =>\n    val rules =  cfg.R.filter(_.lhs == n)\n    val sampled = rules(rand.nextInt(rules.length))\n    val children = sampled.rhs.map(generateTree(cfg,_))\n    Node(n,children)\n} ",
      "extraFields" : {
        "hide_output" : "true",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP,'VP),   \\n  'VP -> List('VB), 'VP -> List('VB,'PP), 'VP -> List('VB,'ADJ),\\n  'PP -> List('IN, 'NP),\\n  'VB -> \\\"are\\\", 'VB -> \\\"raps\\\",\\n  'NP -> List('NX,'NX),'NP -> 'NX, 'NP -> List('ADJ,'NP),\\n  'NX -> \\\"StatNLP\\\", 'NX -> \\\"MCRiedel\\\", 'NX -> \\\"raps\\\",\\n  'IN -> \\\"during\\\",\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S))\",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toWolfeTree(tree:ParseTree):ConstituentTree = tree match {\\n  case Node(NonTerminal(l),Leaf(Terminal(w)) :: Nil) => \\n    ConstituentTree(PreterminalNode(-1,-1,l.toString,w))\\n  case Node(NonTerminal(l), children) =>\\n    ConstituentTree(NonterminalNode(-1,-1,l.toString),children map toWolfeTree)\\n  case Leaf(Terminal(w)) => \\n    ConstituentTree(PreterminalNode(-1,-1,\\\"PreTerm\\\",w))\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toWolfeTree(tree))\\n\",\"Node('NP, List(Node('Adj, List(Leaf(\\\"silly\\\"))),\\n               Node('NP,List(Leaf(\\\"raps\\\")))))  \"]"
      }
    }
  }, {
    "id" : 16,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nNow let us generate a tree, starting from a non-terminal in the CFG.",
      "extraFields" : { }
    }
  }, {
    "id" : 17,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "generateTree(cfg,'S)     ",
      "extraFields" : {
        "cache" : "false",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"MCRiedel\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"MCRiedel\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S))   \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"MCRiedel\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \"]"
      }
    }
  }, {
    "id" : 18,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Finding Parse Trees\nAs you can see, parse trees uncover how a sentence is structured with respect to a grammar. In fact, they give us insights about both constituency and grammatical relations: (TODO: describe example, but use better example first). It is interesting to generate trees and hence sentences given a starting symbol. However, in practice it is often more useful to find a parse tree given a sentence, if existent. This process is generally referred to as parsing. <span class=\"summary\"> **Parsing**: find a legal parse tree given a sentence and a grammar.</span>\n\nThere are a couple of approaches to find a legal parse tree given a sentence and grammar:<span class=\"summary\"></span>\n\n* **Top-Down**: Start with the start symbol and generate trees; backtrack if they do not match observed sentence.\n* **Bottom-Up**: Start with the sentence, and find rules that generate parts of it; backtrack if no start symbol can be induced.\n* **Dynamic Programming**: Explore several trees in parallel and re-use computations.\n\n<div class=\"newslide\"></div>\n#### Bottom-Up Parsing with Backtracking\nA bottom-up parser with backtracking maintains a state consisting of a stack of processed trees, and buffer of remaining words, and a history of previous states we can backtrack to if we cannot make more progress. Roughly speaking, the algorithm proceeds by iteratively reducing the stack via rules to new trees, moving forward in the sentence, and backtracking to previous states when we reach the end of the sentence but cannot create a single tree. <span class=\"summary\"> **Reduce** a stack of trees using rules, **shift** tokens on the stack, **backtrack** when we reach the end but have more than one tree on the stack.</span>\n\n<div class=\"newslide\"></div>\nIn Scala code the parsing algorithm can be formulated as follows. Notice the use of immutable data structures which makes storing and recalling previous states very efficient. Also notice that we record a history of transitions. This is not needed for the algorithm to work, but allows us to inspect its behaviour afterwards. <span class=\"summary\">A scala bottom up parser:</span>",
      "extraFields" : { }
    }
  }, {
    "id" : 19,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "type Stack = List[ParseTree]\ntype Buffer = List[String]\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\ncase class Transition(state:State, op:Symbol)\n\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\n  var history:List[State] = Nil\n  var state = State(Nil,sentence,Nil)\n  var transitions = Transition(state,'Init) :: Nil\n  def reduce() {\n    while (state.rules.nonEmpty) {\n      val rule = state.rules.head\n      val top = state.stack.take(rule.rhs.length).reverse\n      if (top.map(_.node) == rule.rhs) {\n        history = state :: history \n        state = state.copy(\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\n          rules = cfg.R\n        )\n        transitions = Transition(state,'Reduce) :: transitions\n\n      } else state = state.copy(rules = state.rules.tail)\n    }   \n  }\n  def shift() {\n    state = state.copy(\n      stack = Leaf(state.buffer.head) :: state.stack,  \n      buffer = state.buffer.tail, \n      rules = cfg.R\n    )\n    transitions = Transition(state,'Shift) :: transitions\n  }\n  def backtrack() {\n    state = history.head.copy(rules = history.head.rules.tail) \n    transitions = Transition(state,'Backtrack) :: transitions\n    history = history.tail\n  }\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\n    if (state.rules.nonEmpty) reduce()\n    if (state.buffer.nonEmpty) shift() \n    else if (state.stack.length > 1) backtrack()\n  }\n  transitions \n}",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"MCRiedel\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"MCRiedel\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S))   \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"MCRiedel\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \"]"
      }
    }
  }, {
    "id" : 20,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def treeToString(tree:ParseTree):String = tree match {\n  case Node(NonTerminal(n), children) => s\"($n ${children.map(treeToString).mkString(\" \")})\"\n  case Leaf(Terminal(w)) => w\n}\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\" | \"),t.state.buffer.mkString(\" \"))\n  table(transitions.map(toRow))\n} ",
      "extraFields" : {
        "hide" : "true",
        "hide_output" : "true",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"MCRiedel\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"MCRiedel\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S))   \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"MCRiedel\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    println(\\\"Stack:\\\" + state.stack.map(_.node).mkString(\\\" \\\"))  \\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      println(rule)    \\n      val top = state.stack.take(rule.rhs.length).reverse\\n      println(top.map(_.node).mkString(\\\" \\\"))\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty)) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() // this should only happen if we aren't backtracking \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n}\"]"
      }
    }
  }, {
    "id" : 21,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Let us run an example parse.",
      "extraFields" : { }
    }
  }, {
    "id" : 22,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "bottomUpParse(cfg, List(\"MCRiedel\", \"raps\", \"are\", \"silly\")).reverse     ",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"MCRiedel\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"MCRiedel\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S))   \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"MCRiedel\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n}\",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n} \"]"
      }
    }
  }, {
    "id" : 23,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Probabilistic Context Free Grammars\n[Probabilistic Context Free Grammars](http://www.cs.columbia.edu/~mcollins/courses/nlp2011/notes/pcfgs.pdf) (PFCGs) are [Context Free Grammars](https://www.cs.rochester.edu/~nelson/courses/csc_173/grammars/cfg.html) where rules have probabilities. More formally, a PCFG consists of \n\n* A Context Free Grammar \\\\(G=(N,\\Sigma,R,S)\\\\).\n* A parameter \\\\(q(\\alpha \\rightarrow \\beta)\\\\) for each rule  \\\\(\\alpha \\rightarrow \\beta \\in R\\\\).\n\n<div class=\"newslide\"></div>\nBefore we show examples, let us define a scala data structure for\nPCFGs.    ",
      "extraFields" : { }
    }
  }, {
    "id" : 24,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "case class ProbRule(rule:Rule,prob:Double)\ncase class PCFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[ProbRule],S:NonTerminal)",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP,'VP),   \\n  'VP -> List('VB), 'VP -> List('VB,'PP), 'VP -> List('VB,'ADJ),\\n  'PP -> List('IN, 'NP),\\n  'VB -> \\\"are\\\", 'VB -> \\\"raps\\\",\\n  'NP -> List('NX,'NX),'NP -> 'NX, 'NP -> List('ADJ,'NP),\\n  'NX -> \\\"StatNLP\\\", 'NX -> \\\"MCRiedel\\\", 'NX -> \\\"raps\\\",\\n  'IN -> \\\"during\\\",\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S))\",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toWolfeTree(tree:ParseTree):ConstituentTree = tree match {\\n  case Node(NonTerminal(l),Leaf(Terminal(w)) :: Nil) => \\n    ConstituentTree(PreterminalNode(-1,-1,l.toString,w))\\n  case Node(NonTerminal(l), children) =>\\n    ConstituentTree(NonterminalNode(-1,-1,l.toString),children map toWolfeTree)\\n  case Leaf(Terminal(w)) => \\n    ConstituentTree(PreterminalNode(-1,-1,\\\"PreTerm\\\",w))\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toWolfeTree(tree))\\n\",\"Node('NP, List(Node('Adj, List(Leaf(\\\"silly\\\"))),\\n               Node('NP,List(Leaf(\\\"raps\\\")))))  \",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)      \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty)) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() // this should only happen if we aren't backtracking \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n}\",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\",\"bottomUpParse(cfg, List(\\\"are\\\", \\\"silly\\\")).reverse\"]",
        "hide_output" : "true"
      }
    }
  }, {
    "id" : 25,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nLet us now create an example PCFG. ",
      "extraFields" : { }
    }
  }, {
    "id" : 26,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "implicit def toNonTerm(name:Symbol) = NonTerminal(name)\nimplicit def toTerm(word:String) = Terminal(word)\nval anyToRhs:PartialFunction[Any,RHS] = {\n  case s:String => toTerm(s) \n  case s:Symbol => toNonTerm(s) \n}\nimplicit def toRule1(rule:(Symbol,(List[Any],Double))) = \n  ProbRule(Rule(rule._1,rule._2._1.collect(anyToRhs)), rule._2._2) \n\nimplicit def toRule2(rule:(Symbol,(Any,Double))) = \n  ProbRule(Rule(rule._1,List(anyToRhs(rule._2._1))),rule._2._2) \n    \nimplicit def toHTML(pcfg:PCFG) = {\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\n      if (x == pcfg.S) -1 else if (y == pcfg.S) 1 else x.name.toString.compareTo(y.name.toString)\n    }  \n  }      \n  table(pcfg.R.sortBy(_.rule.lhs).map(r => Seq(r.rule.lhs.name,r.rule.rhs.map(rhsToString).mkString(\" \"),r.prob)))    \n}",
      "extraFields" : {
        "hide" : "true",
        "hide_output" : "true",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP,'VP),   \\n  'VP -> List('VB), 'VP -> List('VB,'PP), 'VP -> List('VB,'ADJ),\\n  'PP -> List('IN, 'NP),\\n  'VB -> \\\"are\\\", 'VB -> \\\"raps\\\",\\n  'NP -> List('NX,'NX),'NP -> 'NX, 'NP -> List('ADJ,'NP),\\n  'NX -> \\\"StatNLP\\\", 'NX -> \\\"MCRiedel\\\", 'NX -> \\\"raps\\\",\\n  'IN -> \\\"during\\\",\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S))\",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toWolfeTree(tree:ParseTree):ConstituentTree = tree match {\\n  case Node(NonTerminal(l),Leaf(Terminal(w)) :: Nil) => \\n    ConstituentTree(PreterminalNode(-1,-1,l.toString,w))\\n  case Node(NonTerminal(l), children) =>\\n    ConstituentTree(NonterminalNode(-1,-1,l.toString),children map toWolfeTree)\\n  case Leaf(Terminal(w)) => \\n    ConstituentTree(PreterminalNode(-1,-1,\\\"PreTerm\\\",w))\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toWolfeTree(tree))\\n\",\"Node('NP, List(Node('Adj, List(Leaf(\\\"silly\\\"))),\\n               Node('NP,List(Leaf(\\\"raps\\\"))))) \",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)      \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty)) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() // this should only happen if we aren't backtracking \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n}\",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\",\"bottomUpParse(cfg, List(\\\"are\\\", \\\"silly\\\")).reverse\",\"case class ProbRule(rule:Rule,prob:Double)\\ncase class PCFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[ProbRule],S:NonTerminal)\"]"
      }
    }
  }, {
    "id" : 27,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val example = PCFG(\n    Set('NP,'Adj,'Noun),\n    Set(\"green\",\"house\",\"blue\"),\n    List('NP -> (List('Adj,'Noun),1.0), \n         'Adj -> (\"green\",0.9), 'Adj -> (\"blue\",0.1),\n         'Noun -> (\"house\",1.0)),\n    'NP) \nexample ",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}\",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP,'VP),   \\n  'VP -> List('VB), 'VP -> List('VB,'PP), 'VP -> List('VB,'ADJ),\\n  'PP -> List('IN, 'NP),\\n  'VB -> \\\"are\\\", 'VB -> \\\"raps\\\",\\n  'NP -> List('NX,'NX),'NP -> 'NX, 'NP -> List('ADJ,'NP),\\n  'NX -> \\\"StatNLP\\\", 'NX -> \\\"MCRiedel\\\", 'NX -> \\\"raps\\\",\\n  'IN -> \\\"during\\\",\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S))\",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toWolfeTree(tree:ParseTree):ConstituentTree = tree match {\\n  case Node(NonTerminal(l),Leaf(Terminal(w)) :: Nil) => \\n    ConstituentTree(PreterminalNode(-1,-1,l.toString,w))\\n  case Node(NonTerminal(l), children) =>\\n    ConstituentTree(NonterminalNode(-1,-1,l.toString),children map toWolfeTree)\\n  case Leaf(Terminal(w)) => \\n    ConstituentTree(PreterminalNode(-1,-1,\\\"PreTerm\\\",w))\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toWolfeTree(tree))\\n\",\"Node('NP, List(Node('Adj, List(Leaf(\\\"silly\\\"))),\\n               Node('NP,List(Leaf(\\\"raps\\\")))))  \",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)      \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty)) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() // this should only happen if we aren't backtracking \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n}\",\"bottomUpParse(cfg, List(\\\"are\\\", \\\"silly\\\")).head.state.stack.head \",\"case class ProbRule(rule:Rule,prob:Double)\\ncase class PCFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[ProbRule],S:NonTerminal)\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,(List[Any],Double))) = \\n  ProbRule(Rule(rule._1,rule._2._1.collect(anyToRhs)), rule._2._2) \\n\\nimplicit def toRule2(rule:(Symbol,(Any,Double))) = \\n  ProbRule(Rule(rule._1,List(anyToRhs(rule._2._1))),rule._2._2) \\n    \\nimplicit def toHTML(pcfg:PCFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == pcfg.S) -1 else if (y == pcfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(pcfg.R.sortBy(_.rule.lhs).map(r => Seq(r.rule.lhs.name,r.rule.rhs.map(rhsToString).mkString(\\\" \\\"),r.prob)))    \\n}\"]",
        "hide_output" : "false"
      }
    }
  } ],
  "config" : { }
}
