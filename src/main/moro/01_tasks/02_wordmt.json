{
  "name" : "Word-based Machine Translation",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Machine Translation (MT) is one of the canonical NLP applications, and one that nowadays most people are familiar with, primarily through online translation services of the major search engine providers. While there is still some way to go before machines can provide fluent and flawless translations, in particular for more distant language pairs like English and Japanese, progress in this field has been remarkable. \n\nIn this chapter we will illustrate the foundations of this progress, and focus on word-based machine translation models. Nowaways the field has mostly moved to phrase and syntax-based approaches, but the word-based approach is still important, both from a foundational point of view, and as sub-component in more complex approaches.  \n\n### MT as Structured Prediction \n\nFormally we will see MT as the task of translating a _source_ sentence \\\\(\\source\\\\) to a _target_ sentence \\\\(\\target\\\\). We can again, conceptually, tackle the problem using the [structured prediction recipe](todo): We define a parametrised model \\\\(s_\\params(\\target,\\source)\\\\) that measures how well a target  \\\\(\\target\\\\) sentence matches a source sentence \\\\(\\source\\\\), learn the parameters \\\\(\\params\\\\) from training data, and then find \n$$\n  \\argmax_\\target s_\\params(\\target,\\source)  \n$$\nas translation of \\\\(\\source\\\\). Different _statistical_ MT approaches, in this view, differ primarily in how \\\\(s\\\\) is defined, \\\\(\\params\\\\) are learned, and how the \\\\(\\argmax\\\\) is found. \n\n### Noisy Channel Model for MT\nMany Word-based MT systems, as well as those based on more advanced representations, rely on a [Noisy Channel](todo) model. In this approach to MT we effectively model the translation process *in reverse*. That is, we assume that a probabilistic process (the speaker's brain) first generates the target sentence \\\\(\\target\\\\) according to the distribution \\\\(\\prob(\\target)\\\\). Then the target sentence \\\\(\\target\\\\) is transmitted through a _noisy channel_ \\\\(\\prob(\\source|\\target)\\\\) that translates \\\\(\\target\\\\) into \\\\(\\source\\\\). Hence translation is seen as adding noise to a clean \\\\(\\target\\\\). This _generative story_ defines a _joint distribution_ over target and source sentences \\\\(\\prob(\\source,\\target) = \\prob(\\target) \\prob(\\source|\\target) \\\\). We can in turn operate this distribution in the direction we actually care about: to infer a target sentence \\\\(\\target\\\\) given a source sentence \\\\(\\source\\\\) we find the _maximum a posteriori_ sentence\n$$\n\\target^* = \\argmax_\\target \\prob(\\target | \\source) = \\argmax_\\target \\prob(\\target) \\, \\prob(\\source | \\target). \n$$\n\nIn the noisy channel approach for MT the distribution that generates the target sentence is usually referred to as [language model](/template/statnlpbook/01_tasks/01_languagemodels), and the noisy channel is called the _translation model_. As we have discussed language models earlier, in this chapter we focus on the translation model \\\\(\\prob(\\source|\\target)\\\\).\n\n### A Naive Baseline Translation Model\nThe most straightforward translation model translates words one-by-one, in the order of appearance:\n$$\n\\prob(\\source|\\target) = \\prod_i^{\\length{\\target}} \\prob(\\ssource_i | \\starget_i) \n$$\nwhere \\\\(\\prob(\\ssource_i | \\starget_i) \\\\) is the probability of translating \\\\(\\starget_i\\\\) as \\\\(\\ssource_i\\\\). These per-word distributions appear in many word-based models, are often refered to _translation tables_ and constitute the main parameters of the model. We will identify \\\\(\\prob(\\ssource | \\starget) \\\\) with \\\\(\\param_{\\ssource,\\starget}\\\\) and will define our naive model as \\\\(\\prob_\\params^\\text{Naive}(\\ssource|\\starget) = \\prod_i^{\\length{\\target}} \\param_{\\ssource_i,\\starget_i} \\\\).  \n\nFor many language pairs one can acquire training sets \\\\(\\train=\\left( \\left(\\source_i,\\target_i\\right) \\right)_{i=1}^n \\\\) of paired source and target sentences. For example, for French and English the [Aligned Hansards](http://www.isi.edu/natural-language/download/hansard/) of the Parliament of Canada can be used. Given such a training set \\\\(\\train\\\\) we can learn the parameters \\\\(\\params\\\\) using the [Maximum Likelhood estimator](todo). In the case of our Naive model this amounts to setting\n$$\n\\prob(\\ssource | \\starget) = \\param_{\\ssource,\\starget} = \\frac{\\text{count TODO}}{\\text{count TODO}} \n$$\n##### Exercise\nDerive the maximum likelhood estimate for \\\\(\\prob_\\params^\\text{Naive}\\\\) for training data \\\\(\\train=\\left( \\left(\\source_i,\\target_i\\right) \\right)_{i=1}^n \\\\). \n\n#### Training the Naive Model\nLet us preprare some toy data to show how train this naive model.\n",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 1,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val train = Seq(\n  \"the house is small\" -> \"das Haus ist klein\",\n  \"the house is small\" -> \"klein ist das Haus\",\n  \"a man is tall\" -> \"ein Mann ist gross\",\n  \"my house is small\" -> \"klein ist mein Haus\"\n) map (p => segment(p _1).sentences.head -> segment(p _2).sentences.head)\ntrain.size",
      "extraFields" : {
        "aggregatedCells" : "[]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Notice how we transformed raw strings into [Document](todo) objects via `segment`, and how we then fill the training set with [Sentence](todo) objects by extracting the documents `head` sentence from each document. This dataset can be used to train the naive model as follows.\n\n##### Exercise\nImplement an non-procedural [functional](https://www.coursera.org/course/progfun) version of this code.\n\n##### Exercise\nMake this work even when sentences don't have the same length. \n\n##### Exercise\nWhich sentences make the problem easier, which harder?",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 3,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import scala.collection.mutable.HashMap\ncase class Param(src:String, tgt: String, prob: Double)\ntype Model = Seq[Param]\ndef learn(data:Seq[(Sentence,Sentence)]):Model = {\n  val norm = new HashMap[String,Double] withDefaultValue 0.0\n  val counts = new HashMap[(String,String),Double] withDefaultValue 0.0\n  for ((target,source) <- data) {\n    for (i <- 0 until target.tokens.length) {\n      norm(target.tokens(i).word) += 1.0\n      counts(source.tokens(i).word -> target.tokens(i).word) += 1.0\n    }    \n  }\n  counts.toSeq map {case ((source,target),count) => Param(source,target,count/norm(target)) }\n}\nval model = learn(train)\nbarChart(model sortBy(_.tgt) map(p => (p.src,p.tgt) -> p.prob))",
      "extraFields" : {
        "aggregatedCells" : "[\"val train = Seq(\\n  \\\"the house is small\\\" -> \\\"das Haus ist klein\\\",\\n  \\\"the house is small\\\" -> \\\"klein ist das Haus\\\",\\n  \\\"a man is tall\\\" -> \\\"ein Mann ist gross\\\",\\n  \\\"my house is small\\\" -> \\\"klein ist mein Haus\\\"\\n) map (p => segment(p _1).sentences.head -> segment(p _2).sentences.head)\\ntrain.size\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 4,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "#### Decoding with the Naive Model\n\nBlah",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 5,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def decode(source:Sentence, model:Model) = {\n  val source2targets = model groupBy (_.src) //create one sub-model per source word\n  val source2Best = source2targets mapValues (m => (m maxBy (_.prob)).tgt) //only keep best target\n  val words = source.tokens map (s => source2Best(s.word))\n  Document(IndexedSeq(words))\n}\nval source = train(1)._2\nval target = decode(source, model)\nrenderTokens(target)",
      "extraFields" : {
        "aggregatedCells" : "[\"val train = Seq(\\n  \\\"the house is small\\\" -> \\\"das Haus ist klein\\\",\\n  \\\"the house is small\\\" -> \\\"klein ist das Haus\\\",\\n  \\\"a man is tall\\\" -> \\\"ein Mann ist gross\\\",\\n  \\\"my house is small\\\" -> \\\"klein ist mein Haus\\\"\\n) map (p => segment(p _1).sentences.head -> segment(p _2).sentences.head)\\ntrain.size\",\"import scala.collection.mutable.HashMap\\ncase class Param(src:String, tgt: String, prob: Double)\\ntype Model = Seq[Param]\\ndef learn(data:Seq[(Sentence,Sentence)]):Model = {\\n  val norm = new HashMap[String,Double] withDefaultValue 0.0\\n  val counts = new HashMap[(String,String),Double] withDefaultValue 0.0\\n  for ((target,source) <- data) {\\n    for (i <- 0 until target.tokens.length) {\\n      norm(target.tokens(i).word) += 1.0\\n      counts(source.tokens(i).word -> target.tokens(i).word) += 1.0\\n    }    \\n  }\\n  counts.toSeq map {case ((source,target),count) => Param(source,target,count/norm(target)) }\\n}\\nval model = learn(train)\\nbarChart(model sortBy(_.tgt) map(p => (p.src,p.tgt) -> p.prob))\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 6,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "The naive model is broken in several ways. Most severly, it ignores the fact that word order can differ and still yield (roughly) the same meaning.   \n\n### IBM Model 2\nThe IBM Model 2 is one of the most influential translation models, even though these days it is only indirectly used in actual MT systems, for example to initialize translation (?) and alignment models. As IBM Model 2 can be understood as generalization of IBM Model 1, we omit the latter for now and briefly illustrate it afterward our introduction of Model 2. Notice that parts of these exposition are based on the excellent [lecture notes on IBM Model 1 and 2](http://www.cs.columbia.edu/~mcollins/courses/nlp2011/notes/ibm12.pdf) of Mike Collins.  \n\n#### Alignment\nThe core difference of Model 2 to our naive baseline model is the introduction of a _latent_ auxiliary variables: the word to word _alignment_ \\\\(\\aligns\\\\) between words. In particular, we introduce a variable \\\\(a_i \\in [0 \\ldots \\length{\\target}]\\\\) for each source sentence index \\\\(i \\in [1 \\ldots \\length{\\source}]\\\\). The word alignment \\\\(a_i = j \\\\) means that the source word at token \\\\(i\\\\) is _aligned_ with the target word at index \\\\(j\\\\). Notice that \\\\(\\align_i\\\\) can be \\\\(0\\\\). This corresponds to a imaginary _NULL_ token \\\\(\\starget_0\\\\) in the target sentence and allows source words to be omitted in an aligment. \n\n<p class=\"exercise\">\nHow can _target_ words be omitted in an alignment?\n</p>\nBelow you see a simple \n\n\n\n\n",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 7,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val target = segment(\"NULL the house is small\").sentences(0)\nval source = segment(\"klein ist das Haus\").sentences(0)\nRenderer.renderAlignment(target,source,Seq(1->2,2->3,3->1,4->0))",
      "extraFields" : {
        "aggregatedCells" : "[\"val train = Seq(\\n  \\\"the house is small\\\" -> \\\"das Haus ist klein\\\",\\n  \\\"the house is small\\\" -> \\\"klein ist das Haus\\\",\\n  \\\"a man is tall\\\" -> \\\"ein Mann ist gross\\\",\\n  \\\"my house is small\\\" -> \\\"klein ist mein Haus\\\"\\n) map (p => segment(p _1).sentences.head -> segment(p _2).sentences.head)\\ntrain.size\",\"import scala.collection.mutable.HashMap\\ncase class Param(src:String, tgt: String, prob: Double)\\ntype Model = Seq[Param]\\ndef learn(data:Seq[(Sentence,Sentence)]):Model = {\\n  val norm = new HashMap[String,Double] withDefaultValue 0.0\\n  val counts = new HashMap[(String,String),Double] withDefaultValue 0.0\\n  for ((target,source) <- data) {\\n    for (i <- 0 until target.tokens.length) {\\n      norm(target.tokens(i).word) += 1.0\\n      counts(source.tokens(i).word -> target.tokens(i).word) += 1.0\\n    }    \\n  }\\n  counts.toSeq map {case ((source,target),count) => Param(source,target,count/norm(target)) }\\n}\\nval model = learn(train)\\nbarChart(model sortBy(_.tgt) map(p => (p.src,p.tgt) -> p.prob))\",\"def decode(source:Sentence, model:Model) = {\\n  val source2targets = model groupBy (_.src) //create one sub-model per source word\\n  val source2Best = source2targets mapValues (m => (m maxBy (_.prob)).tgt) //only keep best target\\n  val words = source.tokens map (s => source2Best(s.word))\\n  Document(IndexedSeq(words))\\n}\\nval source = train(1)._2\\nval target = decode(source, model)\\nrenderTokens(target)\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 8,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "\n\nIBM Model 2 defines a conditional distribution \\\\(\\prob(\\source,\\aligns|\\target)\\\\) over both the source sentence \\\\(\\source\\\\) and its alignment \\\\(\\aligns\\\\) to the target sentence \\\\(\\target\\\\). Such a model can be used as translation model \\\\(\\prob(\\source|\\target)\\\\), as defined above, by marginalizing out the alignment\n\n$$\n\\prob(\\source|\\target) = \\sum_{\\aligns} \\prob(\\source,\\aligns|\\target).\n$$\n\nNotice that pluging this translation model into the _argmax_ decoding (todo: Do I define decoding?) step above results in a nested summation and maximization problem---an [NP-sharp?](todo) problem. To avoid the computational issues that arise in this setting, it is common (but not always [necessary](linktobayespaper)) to instead maximize over both target and alignment at decoding time:\n\n$$\n(\\target^*,\\aligns^*) = \\argmax_{\\target,\\aligns} \\prob(\\target, \\aligns | \\source).\n$$\n\nThis amounts to finding the optimal target and alignment for a given source sentence.  \n\nIBM Model 2 defines its conditional distribution over source and alignments using two sets of parameters \\\\(\\params=(\\balpha,\\bbeta)\\\\). Here \\\\(\\alpha(\\ssource|\\starget)\\\\) is a parameter defining the probability of translation target word \\\\(\\starget\\\\) into source word \\\\(\\ssource\\\\), and \\\\(\\beta(j|i,l_\\starget,l_\\ssource)\\\\) a parameter that defines the probability of aligning the source word at token \\\\(i\\\\) with the target word at token \\\\(j\\\\), conditioned on the length \\\\(l_\\starget\\\\) of the target sentence, and the length \\\\(l_\\ssource\\\\) of the source sentence.\n\nWith the above parameters, IBM Model 2 defines a conditional distribution over source sentences and alignments, conditioned on a target sentence _and a desired source sentence length_ \\\\(l_\\ssource\\\\):\n$$\n  p_\\params^\\text{IBM2}(\\ssource_1 \\ldots \\ssource_{l_\\ssource},\\align_1 \\ldots \\align_{l_\\ssource}|\\starget_1 \\ldots \\starget_{l_\\starget}, l_\\ssource) = \\prod_i^{l_\\starget} \\alpha(\\ssource_i|\\starget_{a_i}) \\beta(a_i|i,l_\\starget,l_\\ssource)\n$$\n\nStory: show how easy learning of a better alignment model is when you are given gold alignments (define the method for that). Then say we don't have alignment, and introduce EM.\n\n\n### Something else\nBut what?\n\n\"Yo\"\n\n  * Like this?\n  * Me too!\n\n\nPeace\n",
      "extraFields" : {
        "aggregatedCells" : "[\"1 + 3\\n\"]"
      },
      "outputFormat" : null
    }
  } ],
  "config" : { }
}
