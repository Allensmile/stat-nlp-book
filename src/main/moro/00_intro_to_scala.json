{
  "name" : "Scala Crash Course",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<span class=\"summary\">\n<div class=\"newslide\"></div>\n# Welcome to the Tutorial!\n\n## Meet your Tutors\n* [George Spithourakis](g.spithourakis.12@ucl.ac.uk)\n* [Johannes Welbl](johannes.welbl.14@ucl.ac.uk)\n* [Tim Rocktäschel](t.rocktaschel@cs.ucl.ac.uk)\n* [Matko Bošnjak](matko.bosnjak@gmail.com)\n\nWe are all 1st or 3rd year NLP/ML PhD students in Sebastian's Machine Reading lab\n\n<div class=\"newslide\"></div>\n## Tutorial Logistics\n* Tuesdays 8am to 10am \n    * Yes, that's early for us too\n    * No, we couldn't do anything about it\n    * Please be here at 8am\n    * Don't show up at 9:59am and expect help\n* Room: MPEB 1.03\n* At least two tutors will be present\n\n<div class=\"newslide\"></div>\n## Why should I be here?\n* This is the place to ask questions\n* We will discuss new assignments\n* We will introduce Scala concepts, libraries and tricks\n* We are here to help you\n* We hope to make your NLP life easier\n* The tutorial is meant to be interactive\n    * Interrupt is!\n    * Ask us!\n\n<div class=\"newslide\"></div>\n## Today's Agenda\n* Get you up and running with Scala\n* Show you how the interactive course book can be run\n* Start with some simple Scala code\n \n<div class=\"newslide\"></div>\n### Next Week\n* Almost everything you have to know about Scala to solve the assignments\n</span>",
      "extraFields" : { }
    }
  }, {
    "id" : 1,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n## Introduction\n\nThis short Scala crash course is based on the execellent [Scala School by Twitter](https://twitter.github.io/scala_school/).<span class=\"summary\"></span>\n\nWe chose Scala as the language for the course (as well as the language we develop our systems in) because of several reasons, some of which are:\n<span class=\"summary\"></span>\n\n* Increasingly used in NLP and ML, but don't take our word for it, take a look at the code of some of the world's leading labs: [UCL Machine Reading group](https://github.com/uclmr/) :), [Berkeley NLP Group](http://nlp.cs.berkeley.edu/) and [another interesting ML project at UC Berkeley](http://bid2.berkeley.edu/bid-data-project/) , [University of Washington](http://knowitall.github.io/openie/), [Allen Institute for Artificial Intelligence](https://github.com/allenai), etc.<span class=\"summary\"></span>\n* Expressive - Scala offers first class functions, and closures, and effectively enables you to quickly rewrite pseudocode or math models to code\n<div class=\"newslide\"></div>\n* Concise - it offers type inference, and is on the quest to eliminate boilerplate code\n* Java interoperability - you can reuse your favorite Java libraries! This comes in VERY handy.\n* Scala is not Java on steroids :) it is just a different, object-oriented *functional* programming language (cannot stress the functional part enough)",
      "extraFields" : { }
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n## Installing Scala\nIn order to install Scala, please follow [these instructions](http://www.scala-lang.org/download/install.html).<span class=\"summary\">www.scala-lang.org/download/install.html</span>\n\nStarting the interpreter: run `scala` from the command line\n\nProgramming in [IntelliJ](https://www.jetbrains.com/idea/): www.jetbrains.com/idea\n\nThere is also an [Scala IDE based on Eclipse](http://scala-ide.org/), but we recommend IntelliJ!",
      "extraFields" : { }
    }
  }, {
    "id" : 3,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## The Simple Build Tool (SBT)\n\nGet it [here](http://www.scala-sbt.org/): http://www.scala-sbt.org/\n\n- A build tool (like Maven)\n- Needed for compiling the assignment code",
      "extraFields" : { }
    }
  }, {
    "id" : 4,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n## Running the StatNLP Book locally\n\nYou need to do this if you want to make use of the interactive part of the tutorial and lecture!\n\n\n```\ngit clone https://github.com/uclmr/stat-nlp-book.git; cd stat-nlp-book\ngit submodule update --init --recursive\nsbt compile\ncd wolfe; sbt compile; sbt publish-local; cd ..\ncp moro/conf/application-statnlpbook.conf moro/conf/application.conf\ncd moro; git checkout master; sbt run\n```\n\nopen `localhost:9000` in your browser",
      "extraFields" : { }
    }
  }, {
    "id" : 5,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n## Scala Basics\n\nThis part of the book concerns the basics of Scala, a quick crash-course of Scala which you will need in order to understand this book, and be able to code up your assignments. All sorts of feedback are welcome and highly appreciated!<span class=\"summary\"></span>\n\nYou can run these commands either in IntelliJ, or by running\n\n`sbt console`\n\nor\n\n`scala`\n\nin your command line, and thus entering Scala's REPL (Read-Evaluate-Print Loop) interpreter.",
      "extraFields" : { }
    }
  }, {
    "id" : 6,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Expressions\n\nAlmost everything in Scala is an expression, for example:\n\nNumerical Calculations",
      "extraFields" : { }
    }
  }, {
    "id" : 7,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "// Scala's interpretes automatically resolves the type of the expression in most cases\n1.5 + 1.21828189",
      "extraFields" : {
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 8,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "However, be aware that Scala's automatic type inference doesn't have to work like you want it to:",
      "extraFields" : { }
    }
  }, {
    "id" : 9,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "22 / 23",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\"]"
      }
    }
  }, {
    "id" : 10,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "In this case, having two Integers, Scala infers that it needs to use integer division, which is wrong if you wanted to get a decimal value.",
      "extraFields" : { }
    }
  }, {
    "id" : 11,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\nString Operations",
      "extraFields" : { }
    }
  }, {
    "id" : 12,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "// see the difference between calling infix operators, and calling them as methods\n\"Soft\" + \" \" + \"kitty,\" + \" warm\".+(\" kitty\")",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\"]"
      }
    }
  }, {
    "id" : 13,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\nLogical expressions",
      "extraFields" : { }
    }
  }, {
    "id" : 14,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "2 > 5 || 5 > 2 && true",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\"]"
      }
    }
  }, {
    "id" : 15,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Values and variables\n\nScala suports values and variables. Values are technically constants, and they cannot be changed (immutable), as opposed to variables which can (mutable). Try removing the commented piece of code to verify that:",
      "extraFields" : { }
    }
  }, {
    "id" : 16,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val value = \"I cannot be changed! Really!\"\n// value = \"But surely, this is not true?!\"\nvalue",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\"]"
      }
    }
  }, {
    "id" : 17,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "var variable = \"However, I can!\"\nvariable = \"See? I can change!\"\nvariable",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\"]"
      }
    }
  }, {
    "id" : 18,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "You might ask yourself: why should I use values and immutable structure? There are several reasons for and against using them. Immutable structures help with reasoning about the code, concurrency, make the code less prone to bugs (no references to take care of), etc. You can find a couple of thoughts about that [here](http://stackoverflow.com/questions/214714/mutable-vs-immutable-objects) and [here](http://programmers.stackexchange.com/questions/151733/if-immutable-objects-are-good-why-do-people-keep-creating-mutable-objects).\nYou might also ask yourself: how do I change something in an immutable structure then? Easily - you copy it with a change in place :)\nHowever, you will see more in the rest of the tutorial.<span class=\"summary\"></span>",
      "extraFields" : { }
    }
  }, {
    "id" : 19,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Control Structures\n\nIf-then-else",
      "extraFields" : { }
    }
  }, {
    "id" : 20,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val word = \"Hello\"\nvar response = \"\"\n\nif (word == \"world\") {\n    response = \"What about it?\"\n} else if (word == \"Hello\") {\n    response = \"Hi!\"\n} else {\n    response = \"I have no idea what you are talking about!\"\n}\nresponse",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\"]"
      }
    }
  }, {
    "id" : 21,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nFor Loop",
      "extraFields" : { }
    }
  }, {
    "id" : 22,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "var count = 0\nfor (i <- 0 to 10) count = count + i\ncount",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\"]"
      }
    }
  }, {
    "id" : 23,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nWhile Loop",
      "extraFields" : { }
    }
  }, {
    "id" : 24,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "var count = 0\nvar i = 0\nwhile (i < 10) {\n    i = i + 1\n    count = count + i\n}\ncount",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\"]"
      }
    }
  }, {
    "id" : 25,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Functions\n\nIn Scala, functions are objects you create with the keyword `def`, e.g.:",
      "extraFields" : { }
    }
  }, {
    "id" : 26,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def sum(a: Int, b: Int): Int = a + b\nsum(9000, 1)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\"]"
      }
    }
  }, {
    "id" : 27,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "As you can see from the definition, you need to specify the type of the parameters, but you can freely omit the output type as the interpreter/compiler will do that implicitly (except in cases of recursive functions).\nFunctions can be stored in variables and passed as parameters, as they are full-fledged Scala objects.<span class=\"summary\"></span>\n\nLet's take a look at a couple of functions' capabilities on a small NLP example - let's build something (maybe) useful which\ndepluralizes (removes suffixes of plural forms of) nouns:<span class=\"summary\"></span>",
      "extraFields" : { }
    }
  }, {
    "id" : 28,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nThey are literally objects!",
      "extraFields" : { }
    }
  }, {
    "id" : 29,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\n\nsum(3,6)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\"]"
      }
    }
  }, {
    "id" : 30,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val verboseSum = new Function2[Int,Int,Int] {\n    def apply(a: Int, b: Int): Int = a + b\n}\n\nverboseSum(3,5)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\"]"
      }
    }
  }, {
    "id" : 31,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "If you don't want your function to return a value (like `void` in C), use `Unit` as a return value:",
      "extraFields" : { }
    }
  }, {
    "id" : 32,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "// println does not return a value\ndef printSum(a: Int, b: Int): Unit = println(a + b)\n// moro prints out the return value, which is non-existent in this case!\nprintSum(15, 667)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\"]"
      }
    }
  }, {
    "id" : 33,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nSince functions are objects, we can pass them to functions!",
      "extraFields" : { }
    }
  }, {
    "id" : 34,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\ndef changeCharacters(s: String, fun: Character => Character) = {\n  val sb = new StringBuilder()\n  val chars = s.toCharArray()\n  for (i <- 0 until s.length()) {\n    sb += fun(chars(i))\n  }\n  sb.toString\n}\n\ndef capitalize(c: Character) = Character.toUpperCase(c)\n\nchangeCharacters(\"Hello, Scala!\", capitalize)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\"]"
      }
    }
  }, {
    "id" : 35,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nThere are different ways of writing functions!",
      "extraFields" : { }
    }
  }, {
    "id" : 36,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def mul(a: Int, b: Int): Int = {\n  return a * b \n}  \n\ndef sub(a: Int, b: Int) = a - b\n\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\n\nsum(8,sub(mul(2, 4), 5))",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\"]"
      }
    }
  }, {
    "id" : 37,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nThe last expression in the body of a function is its return value. Also, functions without arguments can be called without parenthesis.",
      "extraFields" : { }
    }
  }, {
    "id" : 38,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def saySomething = {\n  \"I don't know\" // ignored!\n  \"Okay\"         // ignored!\n  \"This is fun!\"\n}\n\nsaySomething",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\"]"
      }
    }
  }, {
    "id" : 39,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### ???\n\nIn-code TODO statements",
      "extraFields" : { }
    }
  }, {
    "id" : 40,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def ??? : Nothing = throw new NotImplementedError\n\n//todo, but already compiles\ndef answerToLifeTheUniverseAndEverything() = ???\ndef question(s: String) = {\n    if (s == \"the answer to life the universe and everything\")\n        answerToLifeTheUniverseAndEverything()\n    else\n        ???\n}\n\n//already done\ndef answerOnePlusOne() = 2\nanswerOnePlusOne()",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\"]"
      }
    }
  }, {
    "id" : 41,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>",
      "extraFields" : { }
    }
  }, {
    "id" : 42,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def repeatNTimes(word: String, N: Int): String = {\n    ???\n}\n\ndef reverse(word: String): String = {\n    ???\n}\n\n//repeatNTimes(reverse(\"Test\"), 3)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\"]"
      }
    }
  }, {
    "id" : 43,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"exercise\">\n  <div class=\"exname\">Exercise</div>    \n  <div class=\"extext\">Write a function that repeats a word N times.</div>    \n</div>\n<div class=\"exercise\">\n  <div class=\"exname\">Exercise</div>    \n  <div class=\"extext\">Write a function that reverses a word.</div>    \n</div>",
      "extraFields" : { }
    }
  }, {
    "id" : 44,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Variable length arguments",
      "extraFields" : { }
    }
  }, {
    "id" : 45,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def concatenateAll(delimiter: String, args: String*) = {\n    args.foldLeft(\"\")((x: String, y: String) => x + delimiter + y)\n}\nconcatenateAll(\"+\",\"soft\", \"kitty\", \"warm\", \"kitty\")",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\"]"
      }
    }
  }, {
    "id" : 46,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Case Classes\n\nCase classes are regular Scala classes which export their constructor parameters and enable you to recursively decompose them with pattern matching. You don't have to write `new`!",
      "extraFields" : { }
    }
  }, {
    "id" : 47,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "class TokenVerbose(name: String)\ncase class Token(name: String)\n\nval test1 = new TokenVerbose(\"Test1\")\nval test2 = Token(\"Test2\")\nval test3 = Token(\"Test2\")\n\ntest2 == test3",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\"]"
      }
    }
  }, {
    "id" : 48,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n## For Comprehension",
      "extraFields" : { }
    }
  }, {
    "id" : 49,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "case class Sentence(tokens: Seq[String])\ncase class Document(sentences: Seq[Sentence])\n\nval docs = Seq(\n    Document(Seq(Sentence(Seq(\"I\", \"like\", \"Scala\", \".\")))),\n    Document(Seq(Sentence(Seq(\"Really\", \"?\")),\n                 Sentence(Seq(\"I\", \"like\", \"NLP\", \".\")))))\n\nvar shortTokens = 0\nfor (doc <- docs)\n  for (sentence <- doc.sentences)\n    for (token <- sentence.tokens)\n      if (token.length < 3) shortTokens += 1\nshortTokens",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\"]"
      }
    }
  }, {
    "id" : 50,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "shortTokens = 0\nfor (doc <- docs)\n  for (sentence <- doc.sentences)\n    for (token <- sentence.tokens)\n      if (token.length < 3) shortTokens += 1\nshortTokens",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\"]"
      }
    }
  }, {
    "id" : 51,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "shortTokens = 0\nfor {\n  doc <- docs\n  sentence <- doc.sentences\n  token <- sentence.tokens\n  if token.length < 3\n} shortTokens += 1\nshortTokens",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\"]"
      }
    }
  }, {
    "id" : 52,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Pattern Matching\n\nPattern matching is the [second most](http://www.tutorialspoint.com/scala/scala_pattern_matching.htm) used feature of scala. It is a general mechanism which allows you to match on different kinds of data structures.",
      "extraFields" : { }
    }
  }, {
    "id" : 53,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val pattern = \"\"\"(\\w*) Inc\"\"\".r\nval word: Any = \"Google Inc\"\nword match {\n    case \"Microsoft\" | \"Yahoo\" => \"We can match Strings\"\n    case pattern(name) => s\"There is an incorporated company named $name\"\n    case (\"Twitter\", \"Facebook\") => \"Data Structures\"\n    case List(\"A\", \"B\", \"C\") => \"...and lists etc.!\"\n    case Token(\"LinkedIn\") => \"...and even the content inside Case Classes!\"\n}",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\"]"
      }
    }
  }, {
    "id" : 54,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\nWe can define a factorial function with pattern matching as follows.\n\n\\\\(n! = \\prod_{k=1}^n k\\\\)",
      "extraFields" : { }
    }
  }, {
    "id" : 55,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def factorial(n: Int): Int = n match {\n  case 0 | 1 => 1\n  case x => x * factorial(n-1)\n}\n\nfactorial(5)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\"]"
      }
    }
  }, {
    "id" : 56,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n<div class=\"exercise\">\n  <div class=\"exname\">Exercise</div>    \n  <div class=\"extext\">Write a function that calculates the Nth fibonacci number.</div>    \n</div>\n\n\n\\\\(F_n = F_{n-1} + F_{n-2},\\quad F_0 = 0,\\quad F_1 = 1\\\\)",
      "extraFields" : { }
    }
  }, {
    "id" : 57,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def fibonacci(n: Int): Int = n match {\n  case _ => ???\n}\n\n//fibonacci(19) == 4181",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\"]"
      }
    }
  }, {
    "id" : 58,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Class Inheritance",
      "extraFields" : { }
    }
  }, {
    "id" : 59,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "trait LanguageModel {\n  def order:Int     \n  def vocab:Set[String]\n  def probability(word:String, history:String*):Double    \n}\n\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\n  def order = 1\n  def probability(word:String, history:String*) = \n    if (vocab(word)) 1.0 / vocab.size else 0.0\n}\n\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\n  def order = ???\n  def probability(word:String, history:String*) = ???\n}\n\nval vocab = Set(\"This\",\"is\",\"a\",\"test\", \"!\")\nval baseline = UniformLM(vocab)\nbaseline.probability(\"test\")",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\"]"
      }
    }
  }, {
    "id" : 60,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Hello World\n\nSince we have enough understanding of Scala, we can proceed with understanding a Hello World application in it:",
      "extraFields" : { }
    }
  }, {
    "id" : 61,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "// remember, moro shows only the return value, which is an object in this case!\nobject HelloWorld1 extends App {\n    println(\"Hello World!\")\n}",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\"]"
      }
    }
  }, {
    "id" : 62,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "The preferred version of starting your programs:",
      "extraFields" : { }
    }
  }, {
    "id" : 63,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "object HelloWorld2 {\n    def main(args: Array[String]) {\n      println(\"Hello World!\")\n    }\n  }",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\"]"
      }
    }
  }, {
    "id" : 64,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n## Collections\n",
      "extraFields" : { }
    }
  }, {
    "id" : 65,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "In Scala, collections are a set of useful classes and interfaces which enable you (efficient) data storage, and processing. They are divided in mutable and immutable structures (check more about this [here](http://docs.scala-lang.org/overviews/collections/overview.html)).\n\nBefore going further, just a small word on performance:\nknow your data structures! Whatever you are using, if you are concerned with performance, [documentation](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html) is your best friend!",
      "extraFields" : { }
    }
  }, {
    "id" : 66,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Lists\n\nScala lists are an ubiquitous data structure, in its essence a simple [linked lists](https://en.wikipedia.org/wiki/Linked_list) ([#ScalaDoc](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List)), coming in both immutable and mutable flavour.Let's first construct a simple list:",
      "extraFields" : { }
    }
  }, {
    "id" : 67,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val tokens1 = List(\"All\", \"work\", \"and\", \"no\", \"play\", \"makes\",\n                   \"Jack\", \"a\", \"dull\", \"boy\", \".\")\ntokens1",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\"]"
      }
    }
  }, {
    "id" : 68,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nVery useful methods on lists are head and tail. Head of a list is the first element of a list:",
      "extraFields" : { }
    }
  }, {
    "id" : 69,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "tokens1.head",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\"]"
      }
    }
  }, {
    "id" : 70,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "\nwhereas the tail of a list is the list following the first element:",
      "extraFields" : { }
    }
  }, {
    "id" : 71,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "tokens1.tail",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\"]"
      }
    }
  }, {
    "id" : 72,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nLists allow quick addition of an element to the beginning to the list (prepending):",
      "extraFields" : { }
    }
  }, {
    "id" : 73,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\"Jack Torrance: \" :: tokens1",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\"]"
      }
    }
  }, {
    "id" : 74,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nConcatenating two lists:",
      "extraFields" : { }
    }
  }, {
    "id" : 75,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val tokens2 = List(\"Jack\", \"!\", \"What\", \"...\", \"are\", \"you\", \"?\")\ntokens2\nval tokens3 = tokens1 ++ tokens2\ntokens3",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\"]"
      }
    }
  }, {
    "id" : 76,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nA frequently useful method is getting unique elements from a list:",
      "extraFields" : { }
    }
  }, {
    "id" : 77,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val tokens3 = List(\"Breaking\", \"the\", \"law\", \",\", \"breaking\", \"the\", \"law\")\ntokens3.distinct",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\"]"
      }
    }
  }, {
    "id" : 78,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "For more details on lists, including other useful methods check the [documentation](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List) or a [random tutorial](http://www.tutorialspoint.com/scala/scala_lists.htm).",
      "extraFields" : { }
    }
  }, {
    "id" : 79,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Immutable vs mutable list\n\nLists are immutable - they cannot be changed!",
      "extraFields" : { }
    }
  }, {
    "id" : 80,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val immutableList = List(\"Can't\", \"change\", \"this\", \"!\")\n// this won't work:\n// immutableList(0) = \"Can\"",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\"]"
      }
    }
  }, {
    "id" : 81,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "But you can convert it to an array and change:",
      "extraFields" : { }
    }
  }, {
    "id" : 82,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val array = immutableList.toArray\narray(0) = \"Can\"\narray.mkString(\" \")",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\"]"
      }
    }
  }, {
    "id" : 83,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nOr even better, check `scala.collection.mutable` package for various mutable structures, like `ListBuffer`:",
      "extraFields" : { }
    }
  }, {
    "id" : 84,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import scala.collection.mutable.ListBuffer\n// notice var instead of val here!\nvar x = new ListBuffer[String]()\nx += \"Adding\"\nx += \"elements\"\nx += \"Oh, the Joy!\"\nx",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\"]"
      }
    }
  }, {
    "id" : 85,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "If you find yourself lost in immutable structures, check `scala.collection.mutable`",
      "extraFields" : { }
    }
  }, {
    "id" : 86,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nCase classes behave in the same manner:",
      "extraFields" : { }
    }
  }, {
    "id" : 87,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "case class Student(name: String, surname: String)\nval m = Student(\"John\", \"Explosion\")",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\"]"
      }
    }
  }, {
    "id" : 88,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "You cannot change `m`, but you CAN copy it with a change:",
      "extraFields" : { }
    }
  }, {
    "id" : 89,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "m.copy(surname = \"Brutal\")",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\"]"
      }
    }
  }, {
    "id" : 90,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Sets\n\nSets are data structures which store elements without an order and repetition.\n\nAn example of a set is given here:",
      "extraFields" : { }
    }
  }, {
    "id" : 91,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val words1 = Set(\"Do\", \",\", \"or\", \"do\", \"not\", \".\",\n                 \"There\", \"is\", \"no\", \"try\", \".\")\nwords1\n\nval words2 = Set(\"A\", \"martini\", \".\",\n                 \"Shaken\", \",\", \"not\", \"stirred\", \".\")",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\"]"
      }
    }
  }, {
    "id" : 92,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nAnd some of the most useful methods on sets are [union](https://en.wikipedia.org/wiki/Union_\\(set_theory\\)):",
      "extraFields" : { }
    }
  }, {
    "id" : 93,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "words1 union words2",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\"]"
      }
    }
  }, {
    "id" : 94,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n[intersection](https://en.wikipedia.org/wiki/Intersection_\\(set_theory\\)):",
      "extraFields" : { }
    }
  }, {
    "id" : 95,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "words1 intersect words2",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\"]"
      }
    }
  }, {
    "id" : 96,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "and [set difference](https://proofwiki.org/wiki/Definition:Set_Difference):",
      "extraFields" : { }
    }
  }, {
    "id" : 97,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "words1 diff words2",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\"]"
      }
    }
  }, {
    "id" : 98,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Maps\n\nA map (also known as associative array or dictionary) is a collection of key-value pairs, such that each key appears exactly only once.",
      "extraFields" : { }
    }
  }, {
    "id" : 99,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val lemmas = Map(\"saving\" -> \"save\", \"tokens\" -> \"token\",\n                 \"token\" -> \"token\", \"occurring\" -> \"occur\")\nlemmas",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\"]"
      }
    }
  }, {
    "id" : 100,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nFetching the value of a specific key in the map:",
      "extraFields" : { }
    }
  }, {
    "id" : 101,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "lemmas(\"tokens\")",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\"]"
      }
    }
  }, {
    "id" : 102,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "The set of all the keys in a map:",
      "extraFields" : { }
    }
  }, {
    "id" : 103,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "lemmas.keySet",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\"]"
      }
    }
  }, {
    "id" : 104,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Mutable map\n\nAgain, if you find yourself lost in the fact that you cannot add/change/update values in maps, check `scala.collection.mutable` package, which holds a mutable map:",
      "extraFields" : { }
    }
  }, {
    "id" : 105,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "// in this case it is a val...how come?\nval freqs = scala.collection.mutable.Map[String, Int](\"My\" -> 2, \"hovercraft\" -> 2, \"is\" -> 9)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\"]"
      }
    }
  }, {
    "id" : 106,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "...and it is easy to add new elements...",
      "extraFields" : { }
    }
  }, {
    "id" : 107,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "freqs.put(\"full\",  1)\nfreqs",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\"]"
      }
    }
  }, {
    "id" : 108,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n...another way of adding an element",
      "extraFields" : { }
    }
  }, {
    "id" : 109,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "freqs += \"of\" -> 99\nfreqs",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\"]"
      }
    }
  }, {
    "id" : 110,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "and it is easy to change elements (or again, another flavor of adding):",
      "extraFields" : { }
    }
  }, {
    "id" : 111,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "freqs(\"eels\") = 4\nfreqs",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\"]"
      }
    }
  }, {
    "id" : 112,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Tuples\n\nTuples are fixed-length lists in Scala (length up to 22 in Scala), denoted in a specific format:",
      "extraFields" : { }
    }
  }, {
    "id" : 113,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val wordCount = (\"like\", 2)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\"]"
      }
    }
  }, {
    "id" : 114,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "You can access specific elements of that list (first, second) by using the following notation:",
      "extraFields" : { }
    }
  }, {
    "id" : 115,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "wordCount._1\nwordCount._2",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\"]"
      }
    }
  }, {
    "id" : 116,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "A tuple (N=2) is equivalent to a pair (as a key-value pair in the map above):",
      "extraFields" : { }
    }
  }, {
    "id" : 117,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\"like\" -> 2 == (\"like\", 2)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\"]"
      }
    }
  }, {
    "id" : 118,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Option\n\nOptions are containers for optional values, which can contain values `Some(X)`, if a value is present, and `None` if the value is missing. They are very useful to eliminate using `null` as a missing value.\n\nIn the following example, our map `lemmas` contains a method `get` which returns an optional value, whose specific value can then be accessed with a method `get`:",
      "extraFields" : { }
    }
  }, {
    "id" : 119,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val lemmaOpt1 = lemmas.get(\"tokens\")\nlemmaOpt1\nlemmaOpt1.get",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\"]"
      }
    }
  }, {
    "id" : 120,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nIn case this option does not contain a value, get returns a `None`:",
      "extraFields" : { }
    }
  }, {
    "id" : 121,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val lemmaOpt2 = lemmas.get(\"Open the pod bay doors, HAL.\")\nlemmaOpt2\n\nif (lemmaOpt2.isDefined)\n  lemmaOpt2.get\nelse\n  \"I'm sorry, Dave.\"",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\"]"
      }
    }
  }, {
    "id" : 122,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "The `getOrElse` is particularly useful, as it enables you to either obtain a value of an option, or fall back to a default value (its parameter):",
      "extraFields" : { }
    }
  }, {
    "id" : 123,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "lemmaOpt2.getOrElse(\"I'm afraid I can't do that.\").toString",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\"]"
      }
    }
  }, {
    "id" : 124,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n### Important methods on Collections\n\n#### map\n\nApplies a specific function on all the elements in a collection.\n\n`def map[B, Coll[B]](f: A => B): Coll[B]`\n\nThe map method is one of the most frequently used methods.\n\nIn our case, having two sentences in a list:",
      "extraFields" : { }
    }
  }, {
    "id" : 125,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val sentences = List(\"Daisy, Daisy, give me your answer do.\",\n                     \"I'm half crazy all for the love of you.\")\n//sentences.head.toCharArray.map(c => c.toLower).mkString",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\"]"
      }
    }
  }, {
    "id" : 126,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\nWe define a function dyingHal and map it on each sentence in the list:",
      "extraFields" : { }
    }
  }, {
    "id" : 127,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "  def dyingHAL(string: String) = {\n    string.toCharArray.map(c => {\n      val p = math.random\n      if (p > .3) c.toLower\n      else if (p > .05) c.toUpper\n      else '-'\n    }).mkString\n  }\n  \n  sentences.map(dyingHAL).mkString(\" \")",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\"]"
      }
    }
  }, {
    "id" : 128,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\nLet's do a short exercise through which we'll showcase the rest of the functions. Given a text:",
      "extraFields" : { }
    }
  }, {
    "id" : 129,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val text = \"It's not pining, it's passed on! This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!\";",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  \\n  sentences.map(dyingHAL).mkString(\\\" \\\")\"]"
      }
    }
  }, {
    "id" : 130,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Let's do some frequency analysis...",
      "extraFields" : { }
    }
  }, {
    "id" : 131,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n#### flatten\n\nFlattens a collection (of collections...)\n\n`flatten[B]: Coll[B]`\n\nFirst, we'll split the text into sentences over exclamations points. This is a very bad way to do sentence segmentation, but you will learn better ways very soon. Afterwards, we'll split the sentences into words.",
      "extraFields" : { }
    }
  }, {
    "id" : 132,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val sentences = text.split('!')\nval words = sentences.map(_.split(' ')).flatten.toList\nwords.take(10) //first 10 elements (too long otherwise)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  \\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"val text = \\\"It's not pining, it's passed on! This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!\\\";\"]"
      }
    }
  }, {
    "id" : 133,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "The first split creates an array of strings (our sentences). The split inside a map results in an array of arrays of strings (our words, in sentences). As we will take a look only at sentences, we need to flatten everything to a single array.",
      "extraFields" : { }
    }
  }, {
    "id" : 134,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n#### flatMap\n\nApplies a function that returns a sequence to a collection, and flattens the result.\n\n`flatMap[B, Coll[B]](f: A => Coll[B]): Coll[B]`\n\nWe can do the same as previously by invoking flatMap:",
      "extraFields" : { }
    }
  }, {
    "id" : 135,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val alternative = sentences.flatMap(_.split(' ')).toList\nalternative.take(10)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  \\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"val text = \\\"It's not pining, it's passed on! This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!\\\";\",\"val sentences = text.split('!')\\nval words = sentences.map(_.split(' ')).flatten.toList\\nwords.take(10) //first 10 elements (too long otherwise)\"]"
      }
    }
  }, {
    "id" : 136,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n#### filter\n\nFilters out a collection with a Boolean function.\n\n`filter(p: A => Boolean): Coll[A]`\n\nSeeing how our bad sentence splitting (take care of your sentence splitting!) creates some empty strings, we need to filter them out:",
      "extraFields" : { }
    }
  }, {
    "id" : 137,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val filtered = words.filter(_.length > 0).map(_.toLowerCase)\n\n\nfiltered.toList.take(5)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  \\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"val text = \\\"It's not pining, it's passed on! This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!\\\";\",\"val sentences = text.split('!')\\nval words = sentences.map(_.split(' ')).flatten.toList\\nwords.take(10) //first 10 elements (too long otherwise)\",\"val alternative = sentences.flatMap(_.split(' ')).toList\\nalternative.take(10)\"]"
      }
    }
  }, {
    "id" : 138,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "We can also filter out other things, like stopwords:",
      "extraFields" : { }
    }
  }, {
    "id" : 139,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val stopwords = Set(\"the\", \"an\")\nwords.filter(x => x.length > 0 && !stopwords.contains(x)).toList.take(10)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  \\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"val text = \\\"It's not pining, it's passed on! This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!\\\";\",\"val sentences = text.split('!')\\nval words = sentences.map(_.split(' ')).flatten.toList\\nwords.take(10) //first 10 elements (too long otherwise)\",\"val alternative = sentences.flatMap(_.split(' ')).toList\\nalternative.take(10)\",\"val filtered = words.filter(_.length > 0).map(_.toLowerCase)\\n\\n\\nfiltered.toList.take(5)\"]"
      }
    }
  }, {
    "id" : 140,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n#### groupBy\n\nGroups elements of a collection by a specific discriminator function, into key (the value of the descriminator function) and value (a list of all the elements of the starting collection which produce the same value of the descriminator function). \n\n`groupBy[K](f: A => K): Map[K, Coll[K]]`\n\nWe will group our words by themselves:",
      "extraFields" : { }
    }
  }, {
    "id" : 141,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val grouped = filtered.groupBy(x => x)\ngrouped.take(3)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  \\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"val text = \\\"It's not pining, it's passed on! This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!\\\";\",\"val sentences = text.split('!')\\nval words = sentences.map(_.split(' ')).flatten.toList\\nwords.take(10) //first 10 elements (too long otherwise)\",\"val alternative = sentences.flatMap(_.split(' ')).toList\\nalternative.take(10)\",\"val filtered = words.filter(_.length > 0).map(_.toLowerCase)\\n\\n\\nfiltered.toList.take(5)\",\"val stopwords = Set(\\\"the\\\", \\\"an\\\")\\nwords.filter(x => x.length > 0 && !stopwords.contains(x)).toList.take(10)\"]"
      }
    }
  }, {
    "id" : 142,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"exercise\">\n  <div class=\"exname\">Exercise</div>    \n  <div class=\"extext\">Group words by their first letter.</div>    \n</div>",
      "extraFields" : { }
    }
  }, {
    "id" : 143,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n#### mapValues\n\nApplies a function to every value in a map.\n\n`mapValues[C](f: B => C): Map[A, C]`\n\nThe reason we grouped the words by themselves is to count them up easily. We will do that with the mapValues function which applies a desired counting function over the values of our group map.",
      "extraFields" : { }
    }
  }, {
    "id" : 144,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val occurrences = grouped.mapValues(x => x.length)\noccurrences.take(10)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  \\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"val text = \\\"It's not pining, it's passed on! This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!\\\";\",\"val sentences = text.split('!')\\nval words = sentences.map(_.split(' ')).flatten.toList\\nwords.take(10) //first 10 elements (too long otherwise)\",\"val alternative = sentences.flatMap(_.split(' ')).toList\\nalternative.take(10)\",\"val filtered = words.filter(_.length > 0).map(_.toLowerCase)\\n\\n\\nfiltered.toList.take(5)\",\"val stopwords = Set(\\\"the\\\", \\\"an\\\")\\nwords.filter(x => x.length > 0 && !stopwords.contains(x)).toList.take(10)\",\"val grouped = filtered.groupBy(x => x)\\ngrouped.take(3)\"]"
      }
    }
  }, {
    "id" : 145,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n#### maxBy\n\nReturns a maximum value in a collection.\n\n`maxBy[B](f: A => B): A`\n\nOut of curiosity, let's take a look at the most frequent word in our text by using maxBy:",
      "extraFields" : { }
    }
  }, {
    "id" : 146,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "occurrences.maxBy(_._2)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  \\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"val text = \\\"It's not pining, it's passed on! This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!\\\";\",\"val sentences = text.split('!')\\nval words = sentences.map(_.split(' ')).flatten.toList\\nwords.take(10) //first 10 elements (too long otherwise)\",\"val alternative = sentences.flatMap(_.split(' ')).toList\\nalternative.take(10)\",\"val filtered = words.filter(_.length > 0).map(_.toLowerCase)\\n\\n\\nfiltered.toList.take(5)\",\"val stopwords = Set(\\\"the\\\", \\\"an\\\")\\nwords.filter(x => x.length > 0 && !stopwords.contains(x)).toList.take(10)\",\"val grouped = filtered.groupBy(x => x)\\ngrouped.take(3)\",\"val occurrences = grouped.mapValues(x => x.length)\\noccurrences.take(10)\"]"
      }
    }
  }, {
    "id" : 147,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n#### fold\n\nThe fold method comes in three similar flavours, fold, foldLeft and foldRight (check the differences between them [here](https://coderwall.com/p/4l73-a/scala-fold-foldleft-and-foldright)). In its essence, you can view these functions as iterators with an accumulator. Starting with a dedicated starting element, this function applies a function to a starting element and the first element. Then it applies the same function to the result and the second element, and so on...\n\n`foldLeft[B](z: B)(op: (B, A) => B): B`\n\nYou can use, for example, foldLeft to iterate through the map of occurrences and calculate the total number of words:",
      "extraFields" : { }
    }
  }, {
    "id" : 148,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val totalOccurrences = occurrences.foldLeft(0)((count, x) => count + x._2)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  \\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"val text = \\\"It's not pining, it's passed on! This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!\\\";\",\"val sentences = text.split('!')\\nval words = sentences.map(_.split(' ')).flatten.toList\\nwords.take(10) //first 10 elements (too long otherwise)\",\"val alternative = sentences.flatMap(_.split(' ')).toList\\nalternative.take(10)\",\"val filtered = words.filter(_.length > 0).map(_.toLowerCase)\\n\\n\\nfiltered.toList.take(5)\",\"val stopwords = Set(\\\"the\\\", \\\"an\\\")\\nwords.filter(x => x.length > 0 && !stopwords.contains(x)).toList.take(10)\",\"val grouped = filtered.groupBy(x => x)\\ngrouped.take(3)\",\"val occurrences = grouped.mapValues(x => x.length)\\noccurrences.take(10)\",\"occurrences.maxBy(_._2)\"]"
      }
    }
  }, {
    "id" : 149,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nand use that to calculate word frequencies:",
      "extraFields" : { }
    }
  }, {
    "id" : 150,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val frequencies = occurrences.mapValues(_ / totalOccurrences.toDouble)\nfrequencies.take(10)",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  \\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"val text = \\\"It's not pining, it's passed on! This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!\\\";\",\"val sentences = text.split('!')\\nval words = sentences.map(_.split(' ')).flatten.toList\\nwords.take(10) //first 10 elements (too long otherwise)\",\"val alternative = sentences.flatMap(_.split(' ')).toList\\nalternative.take(10)\",\"val filtered = words.filter(_.length > 0).map(_.toLowerCase)\\n\\n\\nfiltered.toList.take(5)\",\"val stopwords = Set(\\\"the\\\", \\\"an\\\")\\nwords.filter(x => x.length > 0 && !stopwords.contains(x)).toList.take(10)\",\"val grouped = filtered.groupBy(x => x)\\ngrouped.take(3)\",\"val occurrences = grouped.mapValues(x => x.length)\\noccurrences.take(10)\",\"occurrences.maxBy(_._2)\",\"val totalOccurrences = occurrences.foldLeft(0)((count, x) => count + x._2)\"]"
      }
    }
  }, {
    "id" : 151,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n\n#### foreach\n\nAs opposed to map, which applies a function to each element of a collection, foreach calls a non-returning procedure over each element, and does not result in a new collection, as map does.\n\n`foreach[U](f: A => U): Unit`\n\nSo, if we'd want to check whether our frequencies sum to 1, we would do the following:",
      "extraFields" : { }
    }
  }, {
    "id" : 152,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "var count = 0.0\nfrequencies.foreach(x => count += x._2)\ncount",
      "extraFields" : {
        "aggregatedCells" : "[\"// Scala's interpretes automatically resolves the type of the expression in most cases\\n1.5 + 1.21828189\",\"22 / 23\",\"// see the difference between calling infix operators, and calling them as methods\\n\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"2 > 5 || 5 > 2 && true\",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"val word = \\\"Hello\\\"\\nvar response = \\\"\\\"\\n\\nif (word == \\\"world\\\") {\\n    response = \\\"What about it?\\\"\\n} else if (word == \\\"Hello\\\") {\\n    response = \\\"Hi!\\\"\\n} else {\\n    response = \\\"I have no idea what you are talking about!\\\"\\n}\\nresponse\",\"var count = 0\\nfor (i <- 0 to 10) count = count + i\\ncount\",\"var count = 0\\nvar i = 0\\nwhile (i < 10) {\\n    i = i + 1\\n    count = count + i\\n}\\ncount\",\"def sum(a: Int, b: Int): Int = a + b\\nsum(9000, 1)\",\"val sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(3,6)\",\"val verboseSum = new Function2[Int,Int,Int] {\\n    def apply(a: Int, b: Int): Int = a + b\\n}\\n\\nverboseSum(3,5)\",\"// println does not return a value\\ndef printSum(a: Int, b: Int): Unit = println(a + b)\\n// moro prints out the return value, which is non-existent in this case!\\nprintSum(15, 667)\",\"//equivalent: def changeCharacters(s: String, fun: Function1[Character, Character]) = {\\ndef changeCharacters(s: String, fun: Character => Character) = {\\n  val sb = new StringBuilder()\\n  val chars = s.toCharArray()\\n  for (i <- 0 until s.length()) {\\n    sb += fun(chars(i))\\n  }\\n  sb.toString\\n}\\n\\ndef capitalize(c: Character) = Character.toUpperCase(c)\\n\\nchangeCharacters(\\\"Hello, Scala!\\\", capitalize)\",\"def mul(a: Int, b: Int): Int = {\\n  return a * b \\n}  \\n\\ndef sub(a: Int, b: Int) = a - b\\n\\nval sum: (Int, Int) => Int = (a: Int, b: Int) => a + b\\n\\nsum(8,sub(mul(2, 4), 5))\",\"def saySomething = {\\n  \\\"I don't know\\\" // ignored!\\n  \\\"Okay\\\"         // ignored!\\n  \\\"This is fun!\\\"\\n}\\n\\nsaySomething\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = {\\n    if (s == \\\"the answer to life the universe and everything\\\")\\n        answerToLifeTheUniverseAndEverything()\\n    else\\n        ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"def repeatNTimes(word: String, N: Int): String = {\\n    ???\\n}\\n\\ndef reverse(word: String): String = {\\n    ???\\n}\\n\\n//repeatNTimes(reverse(\\\"Test\\\"), 3)\",\"def concatenateAll(delimiter: String, args: String*) = {\\n    args.foldLeft(\\\"\\\")((x: String, y: String) => x + delimiter + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"class TokenVerbose(name: String)\\ncase class Token(name: String)\\n\\nval test1 = new TokenVerbose(\\\"Test1\\\")\\nval test2 = Token(\\\"Test2\\\")\\nval test3 = Token(\\\"Test2\\\")\\n\\ntest2 == test3\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor {\\n  doc <- docs\\n  sentence <- doc.sentences\\n  token <- sentence.tokens\\n  if token.length < 3\\n} shortTokens += 1\\nshortTokens\",\"val pattern = \\\"\\\"\\\"(\\\\w*) Inc\\\"\\\"\\\".r\\nval word: Any = \\\"Google Inc\\\"\\nword match {\\n    case \\\"Microsoft\\\" | \\\"Yahoo\\\" => \\\"We can match Strings\\\"\\n    case pattern(name) => s\\\"There is an incorporated company named $name\\\"\\n    case (\\\"Twitter\\\", \\\"Facebook\\\") => \\\"Data Structures\\\"\\n    case List(\\\"A\\\", \\\"B\\\", \\\"C\\\") => \\\"...and lists etc.!\\\"\\n    case Token(\\\"LinkedIn\\\") => \\\"...and even the content inside Case Classes!\\\"\\n}\",\"def factorial(n: Int): Int = n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n}\\n\\nfactorial(5)\",\"def fibonacci(n: Int): Int = n match {\\n  case _ => ???\\n}\\n\\n//fibonacci(19) == 4181\",\"trait LanguageModel {\\n  def order:Int     \\n  def vocab:Set[String]\\n  def probability(word:String, history:String*):Double    \\n}\\n\\ncase class UniformLM(vocab:Set[String]) extends LanguageModel {\\n  def order = 1\\n  def probability(word:String, history:String*) = \\n    if (vocab(word)) 1.0 / vocab.size else 0.0\\n}\\n\\ncase class MyFancyLM(vocab:Set[String]) extends LanguageModel {\\n  def order = ???\\n  def probability(word:String, history:String*) = ???\\n}\\n\\nval vocab = Set(\\\"This\\\",\\\"is\\\",\\\"a\\\",\\\"test\\\", \\\"!\\\")\\nval baseline = UniformLM(vocab)\\nbaseline.probability(\\\"test\\\")\",\"// remember, moro shows only the return value, which is an object in this case!\\nobject HelloWorld1 extends App {\\n    println(\\\"Hello World!\\\")\\n}\",\"object HelloWorld2 {\\n    def main(args: Array[String]) {\\n      println(\\\"Hello World!\\\")\\n    }\\n  }\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\",\"tokens1.head\",\"tokens1.tail\",\"\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\",\"val tokens3 = List(\\\"Breaking\\\", \\\"the\\\", \\\"law\\\", \\\",\\\", \\\"breaking\\\", \\\"the\\\", \\\"law\\\")\\ntokens3.distinct\",\"val immutableList = List(\\\"Can't\\\", \\\"change\\\", \\\"this\\\", \\\"!\\\")\\n// this won't work:\\n// immutableList(0) = \\\"Can\\\"\",\"val array = immutableList.toArray\\narray(0) = \\\"Can\\\"\\narray.mkString(\\\" \\\")\",\"import scala.collection.mutable.ListBuffer\\n// notice var instead of val here!\\nvar x = new ListBuffer[String]()\\nx += \\\"Adding\\\"\\nx += \\\"elements\\\"\\nx += \\\"Oh, the Joy!\\\"\\nx\",\"case class Student(name: String, surname: String)\\nval m = Student(\\\"John\\\", \\\"Explosion\\\")\",\"m.copy(surname = \\\"Brutal\\\")\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\",\"words1 union words2\",\"words1 intersect words2\",\"words1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\",\"lemmas(\\\"tokens\\\")\",\"lemmas.keySet\",\"// in this case it is a val...how come?\\nval freqs = scala.collection.mutable.Map[String, Int](\\\"My\\\" -> 2, \\\"hovercraft\\\" -> 2, \\\"is\\\" -> 9)\",\"freqs.put(\\\"full\\\",  1)\\nfreqs\",\"freqs += \\\"of\\\" -> 99\\nfreqs\",\"freqs(\\\"eels\\\") = 4\\nfreqs\",\"val wordCount = (\\\"like\\\", 2)\",\"wordCount._1\\nwordCount._2\",\"\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\",\"val lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\",\"lemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  \\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"val text = \\\"It's not pining, it's passed on! This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!\\\";\",\"val sentences = text.split('!')\\nval words = sentences.map(_.split(' ')).flatten.toList\\nwords.take(10) //first 10 elements (too long otherwise)\",\"val alternative = sentences.flatMap(_.split(' ')).toList\\nalternative.take(10)\",\"val filtered = words.filter(_.length > 0).map(_.toLowerCase)\\n\\n\\nfiltered.toList.take(5)\",\"val stopwords = Set(\\\"the\\\", \\\"an\\\")\\nwords.filter(x => x.length > 0 && !stopwords.contains(x)).toList.take(10)\",\"val grouped = filtered.groupBy(x => x)\\ngrouped.take(3)\",\"val occurrences = grouped.mapValues(x => x.length)\\noccurrences.take(10)\",\"occurrences.maxBy(_._2)\",\"val totalOccurrences = occurrences.foldLeft(0)((count, x) => count + x._2)\",\"val frequencies = occurrences.mapValues(_ / totalOccurrences.toDouble)\\nfrequencies.take(10)\"]"
      }
    }
  }, {
    "id" : 153,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"exercise\">\n  <div class=\"exname\">Exercise</div>    \n  <div class=\"extext\">Do the same by using the foldLeft function.</div>\n</div>",
      "extraFields" : { }
    }
  } ],
  "config" : { }
}
